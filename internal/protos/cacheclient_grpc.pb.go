// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.18.1
// source: cacheclient.proto

package client_sdk_go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Scs_Get_FullMethodName                    = "/cache_client.Scs/Get"
	Scs_GetBatch_FullMethodName               = "/cache_client.Scs/GetBatch"
	Scs_Set_FullMethodName                    = "/cache_client.Scs/Set"
	Scs_SetBatch_FullMethodName               = "/cache_client.Scs/SetBatch"
	Scs_SetIf_FullMethodName                  = "/cache_client.Scs/SetIf"
	Scs_SetIfNotExists_FullMethodName         = "/cache_client.Scs/SetIfNotExists"
	Scs_Delete_FullMethodName                 = "/cache_client.Scs/Delete"
	Scs_KeysExist_FullMethodName              = "/cache_client.Scs/KeysExist"
	Scs_Increment_FullMethodName              = "/cache_client.Scs/Increment"
	Scs_UpdateTtl_FullMethodName              = "/cache_client.Scs/UpdateTtl"
	Scs_ItemGetTtl_FullMethodName             = "/cache_client.Scs/ItemGetTtl"
	Scs_ItemGetType_FullMethodName            = "/cache_client.Scs/ItemGetType"
	Scs_DictionaryGet_FullMethodName          = "/cache_client.Scs/DictionaryGet"
	Scs_DictionaryFetch_FullMethodName        = "/cache_client.Scs/DictionaryFetch"
	Scs_DictionarySet_FullMethodName          = "/cache_client.Scs/DictionarySet"
	Scs_DictionaryIncrement_FullMethodName    = "/cache_client.Scs/DictionaryIncrement"
	Scs_DictionaryDelete_FullMethodName       = "/cache_client.Scs/DictionaryDelete"
	Scs_DictionaryLength_FullMethodName       = "/cache_client.Scs/DictionaryLength"
	Scs_SetFetch_FullMethodName               = "/cache_client.Scs/SetFetch"
	Scs_SetSample_FullMethodName              = "/cache_client.Scs/SetSample"
	Scs_SetUnion_FullMethodName               = "/cache_client.Scs/SetUnion"
	Scs_SetDifference_FullMethodName          = "/cache_client.Scs/SetDifference"
	Scs_SetContains_FullMethodName            = "/cache_client.Scs/SetContains"
	Scs_SetLength_FullMethodName              = "/cache_client.Scs/SetLength"
	Scs_SetPop_FullMethodName                 = "/cache_client.Scs/SetPop"
	Scs_ListPushFront_FullMethodName          = "/cache_client.Scs/ListPushFront"
	Scs_ListPushBack_FullMethodName           = "/cache_client.Scs/ListPushBack"
	Scs_ListPopFront_FullMethodName           = "/cache_client.Scs/ListPopFront"
	Scs_ListPopBack_FullMethodName            = "/cache_client.Scs/ListPopBack"
	Scs_ListErase_FullMethodName              = "/cache_client.Scs/ListErase"
	Scs_ListRemove_FullMethodName             = "/cache_client.Scs/ListRemove"
	Scs_ListFetch_FullMethodName              = "/cache_client.Scs/ListFetch"
	Scs_ListLength_FullMethodName             = "/cache_client.Scs/ListLength"
	Scs_ListConcatenateFront_FullMethodName   = "/cache_client.Scs/ListConcatenateFront"
	Scs_ListConcatenateBack_FullMethodName    = "/cache_client.Scs/ListConcatenateBack"
	Scs_ListRetain_FullMethodName             = "/cache_client.Scs/ListRetain"
	Scs_SortedSetPut_FullMethodName           = "/cache_client.Scs/SortedSetPut"
	Scs_SortedSetFetch_FullMethodName         = "/cache_client.Scs/SortedSetFetch"
	Scs_SortedSetGetScore_FullMethodName      = "/cache_client.Scs/SortedSetGetScore"
	Scs_SortedSetRemove_FullMethodName        = "/cache_client.Scs/SortedSetRemove"
	Scs_SortedSetIncrement_FullMethodName     = "/cache_client.Scs/SortedSetIncrement"
	Scs_SortedSetGetRank_FullMethodName       = "/cache_client.Scs/SortedSetGetRank"
	Scs_SortedSetLength_FullMethodName        = "/cache_client.Scs/SortedSetLength"
	Scs_SortedSetLengthByScore_FullMethodName = "/cache_client.Scs/SortedSetLengthByScore"
)

// ScsClient is the client API for Scs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScsClient interface {
	Get(ctx context.Context, in *XGetRequest, opts ...grpc.CallOption) (*XGetResponse, error)
	GetBatch(ctx context.Context, in *XGetBatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[XGetResponse], error)
	Set(ctx context.Context, in *XSetRequest, opts ...grpc.CallOption) (*XSetResponse, error)
	SetBatch(ctx context.Context, in *XSetBatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[XSetResponse], error)
	SetIf(ctx context.Context, in *XSetIfRequest, opts ...grpc.CallOption) (*XSetIfResponse, error)
	// Deprecated: Do not use.
	// Deprecated because we have SetIf - Absent to cover this case.
	SetIfNotExists(ctx context.Context, in *XSetIfNotExistsRequest, opts ...grpc.CallOption) (*XSetIfNotExistsResponse, error)
	Delete(ctx context.Context, in *XDeleteRequest, opts ...grpc.CallOption) (*XDeleteResponse, error)
	KeysExist(ctx context.Context, in *XKeysExistRequest, opts ...grpc.CallOption) (*XKeysExistResponse, error)
	Increment(ctx context.Context, in *XIncrementRequest, opts ...grpc.CallOption) (*XIncrementResponse, error)
	UpdateTtl(ctx context.Context, in *XUpdateTtlRequest, opts ...grpc.CallOption) (*XUpdateTtlResponse, error)
	ItemGetTtl(ctx context.Context, in *XItemGetTtlRequest, opts ...grpc.CallOption) (*XItemGetTtlResponse, error)
	ItemGetType(ctx context.Context, in *XItemGetTypeRequest, opts ...grpc.CallOption) (*XItemGetTypeResponse, error)
	DictionaryGet(ctx context.Context, in *XDictionaryGetRequest, opts ...grpc.CallOption) (*XDictionaryGetResponse, error)
	DictionaryFetch(ctx context.Context, in *XDictionaryFetchRequest, opts ...grpc.CallOption) (*XDictionaryFetchResponse, error)
	DictionarySet(ctx context.Context, in *XDictionarySetRequest, opts ...grpc.CallOption) (*XDictionarySetResponse, error)
	DictionaryIncrement(ctx context.Context, in *XDictionaryIncrementRequest, opts ...grpc.CallOption) (*XDictionaryIncrementResponse, error)
	DictionaryDelete(ctx context.Context, in *XDictionaryDeleteRequest, opts ...grpc.CallOption) (*XDictionaryDeleteResponse, error)
	DictionaryLength(ctx context.Context, in *XDictionaryLengthRequest, opts ...grpc.CallOption) (*XDictionaryLengthResponse, error)
	SetFetch(ctx context.Context, in *XSetFetchRequest, opts ...grpc.CallOption) (*XSetFetchResponse, error)
	SetSample(ctx context.Context, in *XSetSampleRequest, opts ...grpc.CallOption) (*XSetSampleResponse, error)
	SetUnion(ctx context.Context, in *XSetUnionRequest, opts ...grpc.CallOption) (*XSetUnionResponse, error)
	SetDifference(ctx context.Context, in *XSetDifferenceRequest, opts ...grpc.CallOption) (*XSetDifferenceResponse, error)
	SetContains(ctx context.Context, in *XSetContainsRequest, opts ...grpc.CallOption) (*XSetContainsResponse, error)
	SetLength(ctx context.Context, in *XSetLengthRequest, opts ...grpc.CallOption) (*XSetLengthResponse, error)
	SetPop(ctx context.Context, in *XSetPopRequest, opts ...grpc.CallOption) (*XSetPopResponse, error)
	ListPushFront(ctx context.Context, in *XListPushFrontRequest, opts ...grpc.CallOption) (*XListPushFrontResponse, error)
	ListPushBack(ctx context.Context, in *XListPushBackRequest, opts ...grpc.CallOption) (*XListPushBackResponse, error)
	ListPopFront(ctx context.Context, in *XListPopFrontRequest, opts ...grpc.CallOption) (*XListPopFrontResponse, error)
	ListPopBack(ctx context.Context, in *XListPopBackRequest, opts ...grpc.CallOption) (*XListPopBackResponse, error)
	ListErase(ctx context.Context, in *XListEraseRequest, opts ...grpc.CallOption) (*XListEraseResponse, error)
	ListRemove(ctx context.Context, in *XListRemoveRequest, opts ...grpc.CallOption) (*XListRemoveResponse, error)
	ListFetch(ctx context.Context, in *XListFetchRequest, opts ...grpc.CallOption) (*XListFetchResponse, error)
	ListLength(ctx context.Context, in *XListLengthRequest, opts ...grpc.CallOption) (*XListLengthResponse, error)
	ListConcatenateFront(ctx context.Context, in *XListConcatenateFrontRequest, opts ...grpc.CallOption) (*XListConcatenateFrontResponse, error)
	ListConcatenateBack(ctx context.Context, in *XListConcatenateBackRequest, opts ...grpc.CallOption) (*XListConcatenateBackResponse, error)
	ListRetain(ctx context.Context, in *XListRetainRequest, opts ...grpc.CallOption) (*XListRetainResponse, error)
	// Add or Updates new element with its score to the Sorted Set.
	// If sorted set doesn't exist, a new one is created with the specified
	// element and its associated score.
	// If an element exists, then its associate score gets overridden with the one
	// provided in this operation.
	SortedSetPut(ctx context.Context, in *XSortedSetPutRequest, opts ...grpc.CallOption) (*XSortedSetPutResponse, error)
	// Fetches a subset of elements in the sorted set.
	SortedSetFetch(ctx context.Context, in *XSortedSetFetchRequest, opts ...grpc.CallOption) (*XSortedSetFetchResponse, error)
	// Gets the specified element and its associated score if it exists in the
	// sorted set.
	SortedSetGetScore(ctx context.Context, in *XSortedSetGetScoreRequest, opts ...grpc.CallOption) (*XSortedSetGetScoreResponse, error)
	// Removes specified elements and their associated scores
	SortedSetRemove(ctx context.Context, in *XSortedSetRemoveRequest, opts ...grpc.CallOption) (*XSortedSetRemoveResponse, error)
	// Changes the score associated with the element by specified amount.
	// If the provided amount is negative, then the score associated with the
	// element is decremented.
	// If the element that needs to be incremented isn't present in the sorted
	// set, it is added with specified number as the score.
	// If the set itself doesn't exist then a new one with specified element and
	// score is created.
	SortedSetIncrement(ctx context.Context, in *XSortedSetIncrementRequest, opts ...grpc.CallOption) (*XSortedSetIncrementResponse, error)
	// Gives the rank of an element.
	SortedSetGetRank(ctx context.Context, in *XSortedSetGetRankRequest, opts ...grpc.CallOption) (*XSortedSetGetRankResponse, error)
	// Returns length of the sorted set
	SortedSetLength(ctx context.Context, in *XSortedSetLengthRequest, opts ...grpc.CallOption) (*XSortedSetLengthResponse, error)
	// Returns number of elements in the sorted set between a given min and max score
	SortedSetLengthByScore(ctx context.Context, in *XSortedSetLengthByScoreRequest, opts ...grpc.CallOption) (*XSortedSetLengthByScoreResponse, error)
}

type scsClient struct {
	cc grpc.ClientConnInterface
}

func NewScsClient(cc grpc.ClientConnInterface) ScsClient {
	return &scsClient{cc}
}

func (c *scsClient) Get(ctx context.Context, in *XGetRequest, opts ...grpc.CallOption) (*XGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XGetResponse)
	err := c.cc.Invoke(ctx, Scs_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) GetBatch(ctx context.Context, in *XGetBatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[XGetResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Scs_ServiceDesc.Streams[0], Scs_GetBatch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[XGetBatchRequest, XGetResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Scs_GetBatchClient = grpc.ServerStreamingClient[XGetResponse]

func (c *scsClient) Set(ctx context.Context, in *XSetRequest, opts ...grpc.CallOption) (*XSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetResponse)
	err := c.cc.Invoke(ctx, Scs_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetBatch(ctx context.Context, in *XSetBatchRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[XSetResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Scs_ServiceDesc.Streams[1], Scs_SetBatch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[XSetBatchRequest, XSetResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Scs_SetBatchClient = grpc.ServerStreamingClient[XSetResponse]

func (c *scsClient) SetIf(ctx context.Context, in *XSetIfRequest, opts ...grpc.CallOption) (*XSetIfResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetIfResponse)
	err := c.cc.Invoke(ctx, Scs_SetIf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *scsClient) SetIfNotExists(ctx context.Context, in *XSetIfNotExistsRequest, opts ...grpc.CallOption) (*XSetIfNotExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetIfNotExistsResponse)
	err := c.cc.Invoke(ctx, Scs_SetIfNotExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) Delete(ctx context.Context, in *XDeleteRequest, opts ...grpc.CallOption) (*XDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDeleteResponse)
	err := c.cc.Invoke(ctx, Scs_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) KeysExist(ctx context.Context, in *XKeysExistRequest, opts ...grpc.CallOption) (*XKeysExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XKeysExistResponse)
	err := c.cc.Invoke(ctx, Scs_KeysExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) Increment(ctx context.Context, in *XIncrementRequest, opts ...grpc.CallOption) (*XIncrementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XIncrementResponse)
	err := c.cc.Invoke(ctx, Scs_Increment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) UpdateTtl(ctx context.Context, in *XUpdateTtlRequest, opts ...grpc.CallOption) (*XUpdateTtlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XUpdateTtlResponse)
	err := c.cc.Invoke(ctx, Scs_UpdateTtl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ItemGetTtl(ctx context.Context, in *XItemGetTtlRequest, opts ...grpc.CallOption) (*XItemGetTtlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XItemGetTtlResponse)
	err := c.cc.Invoke(ctx, Scs_ItemGetTtl_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ItemGetType(ctx context.Context, in *XItemGetTypeRequest, opts ...grpc.CallOption) (*XItemGetTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XItemGetTypeResponse)
	err := c.cc.Invoke(ctx, Scs_ItemGetType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) DictionaryGet(ctx context.Context, in *XDictionaryGetRequest, opts ...grpc.CallOption) (*XDictionaryGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDictionaryGetResponse)
	err := c.cc.Invoke(ctx, Scs_DictionaryGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) DictionaryFetch(ctx context.Context, in *XDictionaryFetchRequest, opts ...grpc.CallOption) (*XDictionaryFetchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDictionaryFetchResponse)
	err := c.cc.Invoke(ctx, Scs_DictionaryFetch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) DictionarySet(ctx context.Context, in *XDictionarySetRequest, opts ...grpc.CallOption) (*XDictionarySetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDictionarySetResponse)
	err := c.cc.Invoke(ctx, Scs_DictionarySet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) DictionaryIncrement(ctx context.Context, in *XDictionaryIncrementRequest, opts ...grpc.CallOption) (*XDictionaryIncrementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDictionaryIncrementResponse)
	err := c.cc.Invoke(ctx, Scs_DictionaryIncrement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) DictionaryDelete(ctx context.Context, in *XDictionaryDeleteRequest, opts ...grpc.CallOption) (*XDictionaryDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDictionaryDeleteResponse)
	err := c.cc.Invoke(ctx, Scs_DictionaryDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) DictionaryLength(ctx context.Context, in *XDictionaryLengthRequest, opts ...grpc.CallOption) (*XDictionaryLengthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XDictionaryLengthResponse)
	err := c.cc.Invoke(ctx, Scs_DictionaryLength_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetFetch(ctx context.Context, in *XSetFetchRequest, opts ...grpc.CallOption) (*XSetFetchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetFetchResponse)
	err := c.cc.Invoke(ctx, Scs_SetFetch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetSample(ctx context.Context, in *XSetSampleRequest, opts ...grpc.CallOption) (*XSetSampleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetSampleResponse)
	err := c.cc.Invoke(ctx, Scs_SetSample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetUnion(ctx context.Context, in *XSetUnionRequest, opts ...grpc.CallOption) (*XSetUnionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetUnionResponse)
	err := c.cc.Invoke(ctx, Scs_SetUnion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetDifference(ctx context.Context, in *XSetDifferenceRequest, opts ...grpc.CallOption) (*XSetDifferenceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetDifferenceResponse)
	err := c.cc.Invoke(ctx, Scs_SetDifference_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetContains(ctx context.Context, in *XSetContainsRequest, opts ...grpc.CallOption) (*XSetContainsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetContainsResponse)
	err := c.cc.Invoke(ctx, Scs_SetContains_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetLength(ctx context.Context, in *XSetLengthRequest, opts ...grpc.CallOption) (*XSetLengthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetLengthResponse)
	err := c.cc.Invoke(ctx, Scs_SetLength_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SetPop(ctx context.Context, in *XSetPopRequest, opts ...grpc.CallOption) (*XSetPopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSetPopResponse)
	err := c.cc.Invoke(ctx, Scs_SetPop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListPushFront(ctx context.Context, in *XListPushFrontRequest, opts ...grpc.CallOption) (*XListPushFrontResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListPushFrontResponse)
	err := c.cc.Invoke(ctx, Scs_ListPushFront_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListPushBack(ctx context.Context, in *XListPushBackRequest, opts ...grpc.CallOption) (*XListPushBackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListPushBackResponse)
	err := c.cc.Invoke(ctx, Scs_ListPushBack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListPopFront(ctx context.Context, in *XListPopFrontRequest, opts ...grpc.CallOption) (*XListPopFrontResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListPopFrontResponse)
	err := c.cc.Invoke(ctx, Scs_ListPopFront_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListPopBack(ctx context.Context, in *XListPopBackRequest, opts ...grpc.CallOption) (*XListPopBackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListPopBackResponse)
	err := c.cc.Invoke(ctx, Scs_ListPopBack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListErase(ctx context.Context, in *XListEraseRequest, opts ...grpc.CallOption) (*XListEraseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListEraseResponse)
	err := c.cc.Invoke(ctx, Scs_ListErase_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListRemove(ctx context.Context, in *XListRemoveRequest, opts ...grpc.CallOption) (*XListRemoveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListRemoveResponse)
	err := c.cc.Invoke(ctx, Scs_ListRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListFetch(ctx context.Context, in *XListFetchRequest, opts ...grpc.CallOption) (*XListFetchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListFetchResponse)
	err := c.cc.Invoke(ctx, Scs_ListFetch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListLength(ctx context.Context, in *XListLengthRequest, opts ...grpc.CallOption) (*XListLengthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListLengthResponse)
	err := c.cc.Invoke(ctx, Scs_ListLength_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListConcatenateFront(ctx context.Context, in *XListConcatenateFrontRequest, opts ...grpc.CallOption) (*XListConcatenateFrontResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListConcatenateFrontResponse)
	err := c.cc.Invoke(ctx, Scs_ListConcatenateFront_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListConcatenateBack(ctx context.Context, in *XListConcatenateBackRequest, opts ...grpc.CallOption) (*XListConcatenateBackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListConcatenateBackResponse)
	err := c.cc.Invoke(ctx, Scs_ListConcatenateBack_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) ListRetain(ctx context.Context, in *XListRetainRequest, opts ...grpc.CallOption) (*XListRetainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XListRetainResponse)
	err := c.cc.Invoke(ctx, Scs_ListRetain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetPut(ctx context.Context, in *XSortedSetPutRequest, opts ...grpc.CallOption) (*XSortedSetPutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetPutResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetPut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetFetch(ctx context.Context, in *XSortedSetFetchRequest, opts ...grpc.CallOption) (*XSortedSetFetchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetFetchResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetFetch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetGetScore(ctx context.Context, in *XSortedSetGetScoreRequest, opts ...grpc.CallOption) (*XSortedSetGetScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetGetScoreResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetGetScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetRemove(ctx context.Context, in *XSortedSetRemoveRequest, opts ...grpc.CallOption) (*XSortedSetRemoveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetRemoveResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetIncrement(ctx context.Context, in *XSortedSetIncrementRequest, opts ...grpc.CallOption) (*XSortedSetIncrementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetIncrementResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetIncrement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetGetRank(ctx context.Context, in *XSortedSetGetRankRequest, opts ...grpc.CallOption) (*XSortedSetGetRankResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetGetRankResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetGetRank_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetLength(ctx context.Context, in *XSortedSetLengthRequest, opts ...grpc.CallOption) (*XSortedSetLengthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetLengthResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetLength_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scsClient) SortedSetLengthByScore(ctx context.Context, in *XSortedSetLengthByScoreRequest, opts ...grpc.CallOption) (*XSortedSetLengthByScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(XSortedSetLengthByScoreResponse)
	err := c.cc.Invoke(ctx, Scs_SortedSetLengthByScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScsServer is the server API for Scs service.
// All implementations must embed UnimplementedScsServer
// for forward compatibility.
type ScsServer interface {
	Get(context.Context, *XGetRequest) (*XGetResponse, error)
	GetBatch(*XGetBatchRequest, grpc.ServerStreamingServer[XGetResponse]) error
	Set(context.Context, *XSetRequest) (*XSetResponse, error)
	SetBatch(*XSetBatchRequest, grpc.ServerStreamingServer[XSetResponse]) error
	SetIf(context.Context, *XSetIfRequest) (*XSetIfResponse, error)
	// Deprecated: Do not use.
	// Deprecated because we have SetIf - Absent to cover this case.
	SetIfNotExists(context.Context, *XSetIfNotExistsRequest) (*XSetIfNotExistsResponse, error)
	Delete(context.Context, *XDeleteRequest) (*XDeleteResponse, error)
	KeysExist(context.Context, *XKeysExistRequest) (*XKeysExistResponse, error)
	Increment(context.Context, *XIncrementRequest) (*XIncrementResponse, error)
	UpdateTtl(context.Context, *XUpdateTtlRequest) (*XUpdateTtlResponse, error)
	ItemGetTtl(context.Context, *XItemGetTtlRequest) (*XItemGetTtlResponse, error)
	ItemGetType(context.Context, *XItemGetTypeRequest) (*XItemGetTypeResponse, error)
	DictionaryGet(context.Context, *XDictionaryGetRequest) (*XDictionaryGetResponse, error)
	DictionaryFetch(context.Context, *XDictionaryFetchRequest) (*XDictionaryFetchResponse, error)
	DictionarySet(context.Context, *XDictionarySetRequest) (*XDictionarySetResponse, error)
	DictionaryIncrement(context.Context, *XDictionaryIncrementRequest) (*XDictionaryIncrementResponse, error)
	DictionaryDelete(context.Context, *XDictionaryDeleteRequest) (*XDictionaryDeleteResponse, error)
	DictionaryLength(context.Context, *XDictionaryLengthRequest) (*XDictionaryLengthResponse, error)
	SetFetch(context.Context, *XSetFetchRequest) (*XSetFetchResponse, error)
	SetSample(context.Context, *XSetSampleRequest) (*XSetSampleResponse, error)
	SetUnion(context.Context, *XSetUnionRequest) (*XSetUnionResponse, error)
	SetDifference(context.Context, *XSetDifferenceRequest) (*XSetDifferenceResponse, error)
	SetContains(context.Context, *XSetContainsRequest) (*XSetContainsResponse, error)
	SetLength(context.Context, *XSetLengthRequest) (*XSetLengthResponse, error)
	SetPop(context.Context, *XSetPopRequest) (*XSetPopResponse, error)
	ListPushFront(context.Context, *XListPushFrontRequest) (*XListPushFrontResponse, error)
	ListPushBack(context.Context, *XListPushBackRequest) (*XListPushBackResponse, error)
	ListPopFront(context.Context, *XListPopFrontRequest) (*XListPopFrontResponse, error)
	ListPopBack(context.Context, *XListPopBackRequest) (*XListPopBackResponse, error)
	ListErase(context.Context, *XListEraseRequest) (*XListEraseResponse, error)
	ListRemove(context.Context, *XListRemoveRequest) (*XListRemoveResponse, error)
	ListFetch(context.Context, *XListFetchRequest) (*XListFetchResponse, error)
	ListLength(context.Context, *XListLengthRequest) (*XListLengthResponse, error)
	ListConcatenateFront(context.Context, *XListConcatenateFrontRequest) (*XListConcatenateFrontResponse, error)
	ListConcatenateBack(context.Context, *XListConcatenateBackRequest) (*XListConcatenateBackResponse, error)
	ListRetain(context.Context, *XListRetainRequest) (*XListRetainResponse, error)
	// Add or Updates new element with its score to the Sorted Set.
	// If sorted set doesn't exist, a new one is created with the specified
	// element and its associated score.
	// If an element exists, then its associate score gets overridden with the one
	// provided in this operation.
	SortedSetPut(context.Context, *XSortedSetPutRequest) (*XSortedSetPutResponse, error)
	// Fetches a subset of elements in the sorted set.
	SortedSetFetch(context.Context, *XSortedSetFetchRequest) (*XSortedSetFetchResponse, error)
	// Gets the specified element and its associated score if it exists in the
	// sorted set.
	SortedSetGetScore(context.Context, *XSortedSetGetScoreRequest) (*XSortedSetGetScoreResponse, error)
	// Removes specified elements and their associated scores
	SortedSetRemove(context.Context, *XSortedSetRemoveRequest) (*XSortedSetRemoveResponse, error)
	// Changes the score associated with the element by specified amount.
	// If the provided amount is negative, then the score associated with the
	// element is decremented.
	// If the element that needs to be incremented isn't present in the sorted
	// set, it is added with specified number as the score.
	// If the set itself doesn't exist then a new one with specified element and
	// score is created.
	SortedSetIncrement(context.Context, *XSortedSetIncrementRequest) (*XSortedSetIncrementResponse, error)
	// Gives the rank of an element.
	SortedSetGetRank(context.Context, *XSortedSetGetRankRequest) (*XSortedSetGetRankResponse, error)
	// Returns length of the sorted set
	SortedSetLength(context.Context, *XSortedSetLengthRequest) (*XSortedSetLengthResponse, error)
	// Returns number of elements in the sorted set between a given min and max score
	SortedSetLengthByScore(context.Context, *XSortedSetLengthByScoreRequest) (*XSortedSetLengthByScoreResponse, error)
	mustEmbedUnimplementedScsServer()
}

// UnimplementedScsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScsServer struct{}

func (UnimplementedScsServer) Get(context.Context, *XGetRequest) (*XGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedScsServer) GetBatch(*XGetBatchRequest, grpc.ServerStreamingServer[XGetResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetBatch not implemented")
}
func (UnimplementedScsServer) Set(context.Context, *XSetRequest) (*XSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedScsServer) SetBatch(*XSetBatchRequest, grpc.ServerStreamingServer[XSetResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SetBatch not implemented")
}
func (UnimplementedScsServer) SetIf(context.Context, *XSetIfRequest) (*XSetIfResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIf not implemented")
}
func (UnimplementedScsServer) SetIfNotExists(context.Context, *XSetIfNotExistsRequest) (*XSetIfNotExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIfNotExists not implemented")
}
func (UnimplementedScsServer) Delete(context.Context, *XDeleteRequest) (*XDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedScsServer) KeysExist(context.Context, *XKeysExistRequest) (*XKeysExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeysExist not implemented")
}
func (UnimplementedScsServer) Increment(context.Context, *XIncrementRequest) (*XIncrementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Increment not implemented")
}
func (UnimplementedScsServer) UpdateTtl(context.Context, *XUpdateTtlRequest) (*XUpdateTtlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTtl not implemented")
}
func (UnimplementedScsServer) ItemGetTtl(context.Context, *XItemGetTtlRequest) (*XItemGetTtlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemGetTtl not implemented")
}
func (UnimplementedScsServer) ItemGetType(context.Context, *XItemGetTypeRequest) (*XItemGetTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemGetType not implemented")
}
func (UnimplementedScsServer) DictionaryGet(context.Context, *XDictionaryGetRequest) (*XDictionaryGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictionaryGet not implemented")
}
func (UnimplementedScsServer) DictionaryFetch(context.Context, *XDictionaryFetchRequest) (*XDictionaryFetchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictionaryFetch not implemented")
}
func (UnimplementedScsServer) DictionarySet(context.Context, *XDictionarySetRequest) (*XDictionarySetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictionarySet not implemented")
}
func (UnimplementedScsServer) DictionaryIncrement(context.Context, *XDictionaryIncrementRequest) (*XDictionaryIncrementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictionaryIncrement not implemented")
}
func (UnimplementedScsServer) DictionaryDelete(context.Context, *XDictionaryDeleteRequest) (*XDictionaryDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictionaryDelete not implemented")
}
func (UnimplementedScsServer) DictionaryLength(context.Context, *XDictionaryLengthRequest) (*XDictionaryLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DictionaryLength not implemented")
}
func (UnimplementedScsServer) SetFetch(context.Context, *XSetFetchRequest) (*XSetFetchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFetch not implemented")
}
func (UnimplementedScsServer) SetSample(context.Context, *XSetSampleRequest) (*XSetSampleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSample not implemented")
}
func (UnimplementedScsServer) SetUnion(context.Context, *XSetUnionRequest) (*XSetUnionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUnion not implemented")
}
func (UnimplementedScsServer) SetDifference(context.Context, *XSetDifferenceRequest) (*XSetDifferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDifference not implemented")
}
func (UnimplementedScsServer) SetContains(context.Context, *XSetContainsRequest) (*XSetContainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetContains not implemented")
}
func (UnimplementedScsServer) SetLength(context.Context, *XSetLengthRequest) (*XSetLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLength not implemented")
}
func (UnimplementedScsServer) SetPop(context.Context, *XSetPopRequest) (*XSetPopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPop not implemented")
}
func (UnimplementedScsServer) ListPushFront(context.Context, *XListPushFrontRequest) (*XListPushFrontResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPushFront not implemented")
}
func (UnimplementedScsServer) ListPushBack(context.Context, *XListPushBackRequest) (*XListPushBackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPushBack not implemented")
}
func (UnimplementedScsServer) ListPopFront(context.Context, *XListPopFrontRequest) (*XListPopFrontResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPopFront not implemented")
}
func (UnimplementedScsServer) ListPopBack(context.Context, *XListPopBackRequest) (*XListPopBackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPopBack not implemented")
}
func (UnimplementedScsServer) ListErase(context.Context, *XListEraseRequest) (*XListEraseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListErase not implemented")
}
func (UnimplementedScsServer) ListRemove(context.Context, *XListRemoveRequest) (*XListRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRemove not implemented")
}
func (UnimplementedScsServer) ListFetch(context.Context, *XListFetchRequest) (*XListFetchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFetch not implemented")
}
func (UnimplementedScsServer) ListLength(context.Context, *XListLengthRequest) (*XListLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLength not implemented")
}
func (UnimplementedScsServer) ListConcatenateFront(context.Context, *XListConcatenateFrontRequest) (*XListConcatenateFrontResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConcatenateFront not implemented")
}
func (UnimplementedScsServer) ListConcatenateBack(context.Context, *XListConcatenateBackRequest) (*XListConcatenateBackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConcatenateBack not implemented")
}
func (UnimplementedScsServer) ListRetain(context.Context, *XListRetainRequest) (*XListRetainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRetain not implemented")
}
func (UnimplementedScsServer) SortedSetPut(context.Context, *XSortedSetPutRequest) (*XSortedSetPutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetPut not implemented")
}
func (UnimplementedScsServer) SortedSetFetch(context.Context, *XSortedSetFetchRequest) (*XSortedSetFetchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetFetch not implemented")
}
func (UnimplementedScsServer) SortedSetGetScore(context.Context, *XSortedSetGetScoreRequest) (*XSortedSetGetScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetGetScore not implemented")
}
func (UnimplementedScsServer) SortedSetRemove(context.Context, *XSortedSetRemoveRequest) (*XSortedSetRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetRemove not implemented")
}
func (UnimplementedScsServer) SortedSetIncrement(context.Context, *XSortedSetIncrementRequest) (*XSortedSetIncrementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetIncrement not implemented")
}
func (UnimplementedScsServer) SortedSetGetRank(context.Context, *XSortedSetGetRankRequest) (*XSortedSetGetRankResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetGetRank not implemented")
}
func (UnimplementedScsServer) SortedSetLength(context.Context, *XSortedSetLengthRequest) (*XSortedSetLengthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetLength not implemented")
}
func (UnimplementedScsServer) SortedSetLengthByScore(context.Context, *XSortedSetLengthByScoreRequest) (*XSortedSetLengthByScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SortedSetLengthByScore not implemented")
}
func (UnimplementedScsServer) mustEmbedUnimplementedScsServer() {}
func (UnimplementedScsServer) testEmbeddedByValue()             {}

// UnsafeScsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScsServer will
// result in compilation errors.
type UnsafeScsServer interface {
	mustEmbedUnimplementedScsServer()
}

func RegisterScsServer(s grpc.ServiceRegistrar, srv ScsServer) {
	// If the following call pancis, it indicates UnimplementedScsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Scs_ServiceDesc, srv)
}

func _Scs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).Get(ctx, req.(*XGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_GetBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(XGetBatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ScsServer).GetBatch(m, &grpc.GenericServerStream[XGetBatchRequest, XGetResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Scs_GetBatchServer = grpc.ServerStreamingServer[XGetResponse]

func _Scs_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).Set(ctx, req.(*XSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(XSetBatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ScsServer).SetBatch(m, &grpc.GenericServerStream[XSetBatchRequest, XSetResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Scs_SetBatchServer = grpc.ServerStreamingServer[XSetResponse]

func _Scs_SetIf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetIfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetIf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetIf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetIf(ctx, req.(*XSetIfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetIfNotExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetIfNotExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetIfNotExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetIfNotExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetIfNotExists(ctx, req.(*XSetIfNotExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).Delete(ctx, req.(*XDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_KeysExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XKeysExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).KeysExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_KeysExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).KeysExist(ctx, req.(*XKeysExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_Increment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XIncrementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).Increment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_Increment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).Increment(ctx, req.(*XIncrementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_UpdateTtl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XUpdateTtlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).UpdateTtl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_UpdateTtl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).UpdateTtl(ctx, req.(*XUpdateTtlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ItemGetTtl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XItemGetTtlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ItemGetTtl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ItemGetTtl_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ItemGetTtl(ctx, req.(*XItemGetTtlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ItemGetType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XItemGetTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ItemGetType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ItemGetType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ItemGetType(ctx, req.(*XItemGetTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_DictionaryGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDictionaryGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).DictionaryGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_DictionaryGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).DictionaryGet(ctx, req.(*XDictionaryGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_DictionaryFetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDictionaryFetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).DictionaryFetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_DictionaryFetch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).DictionaryFetch(ctx, req.(*XDictionaryFetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_DictionarySet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDictionarySetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).DictionarySet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_DictionarySet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).DictionarySet(ctx, req.(*XDictionarySetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_DictionaryIncrement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDictionaryIncrementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).DictionaryIncrement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_DictionaryIncrement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).DictionaryIncrement(ctx, req.(*XDictionaryIncrementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_DictionaryDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDictionaryDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).DictionaryDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_DictionaryDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).DictionaryDelete(ctx, req.(*XDictionaryDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_DictionaryLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XDictionaryLengthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).DictionaryLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_DictionaryLength_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).DictionaryLength(ctx, req.(*XDictionaryLengthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetFetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetFetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetFetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetFetch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetFetch(ctx, req.(*XSetFetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetSample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetSampleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetSample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetSample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetSample(ctx, req.(*XSetSampleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetUnion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetUnionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetUnion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetUnion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetUnion(ctx, req.(*XSetUnionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetDifference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetDifferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetDifference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetDifference_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetDifference(ctx, req.(*XSetDifferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetContains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetContainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetContains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetContains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetContains(ctx, req.(*XSetContainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetLengthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetLength_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetLength(ctx, req.(*XSetLengthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SetPop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSetPopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SetPop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SetPop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SetPop(ctx, req.(*XSetPopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListPushFront_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListPushFrontRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListPushFront(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListPushFront_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListPushFront(ctx, req.(*XListPushFrontRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListPushBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListPushBackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListPushBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListPushBack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListPushBack(ctx, req.(*XListPushBackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListPopFront_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListPopFrontRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListPopFront(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListPopFront_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListPopFront(ctx, req.(*XListPopFrontRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListPopBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListPopBackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListPopBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListPopBack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListPopBack(ctx, req.(*XListPopBackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListErase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListEraseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListErase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListErase_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListErase(ctx, req.(*XListEraseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListRemove(ctx, req.(*XListRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListFetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListFetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListFetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListFetch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListFetch(ctx, req.(*XListFetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListLengthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListLength_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListLength(ctx, req.(*XListLengthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListConcatenateFront_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListConcatenateFrontRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListConcatenateFront(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListConcatenateFront_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListConcatenateFront(ctx, req.(*XListConcatenateFrontRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListConcatenateBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListConcatenateBackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListConcatenateBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListConcatenateBack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListConcatenateBack(ctx, req.(*XListConcatenateBackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_ListRetain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XListRetainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).ListRetain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_ListRetain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).ListRetain(ctx, req.(*XListRetainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetPutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetPut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetPut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetPut(ctx, req.(*XSortedSetPutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetFetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetFetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetFetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetFetch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetFetch(ctx, req.(*XSortedSetFetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetGetScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetGetScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetGetScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetGetScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetGetScore(ctx, req.(*XSortedSetGetScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetRemove(ctx, req.(*XSortedSetRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetIncrement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetIncrementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetIncrement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetIncrement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetIncrement(ctx, req.(*XSortedSetIncrementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetGetRank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetGetRankRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetGetRank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetGetRank_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetGetRank(ctx, req.(*XSortedSetGetRankRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetLength_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetLengthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetLength(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetLength_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetLength(ctx, req.(*XSortedSetLengthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scs_SortedSetLengthByScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(XSortedSetLengthByScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScsServer).SortedSetLengthByScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Scs_SortedSetLengthByScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScsServer).SortedSetLengthByScore(ctx, req.(*XSortedSetLengthByScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Scs_ServiceDesc is the grpc.ServiceDesc for Scs service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Scs_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cache_client.Scs",
	HandlerType: (*ScsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Scs_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _Scs_Set_Handler,
		},
		{
			MethodName: "SetIf",
			Handler:    _Scs_SetIf_Handler,
		},
		{
			MethodName: "SetIfNotExists",
			Handler:    _Scs_SetIfNotExists_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Scs_Delete_Handler,
		},
		{
			MethodName: "KeysExist",
			Handler:    _Scs_KeysExist_Handler,
		},
		{
			MethodName: "Increment",
			Handler:    _Scs_Increment_Handler,
		},
		{
			MethodName: "UpdateTtl",
			Handler:    _Scs_UpdateTtl_Handler,
		},
		{
			MethodName: "ItemGetTtl",
			Handler:    _Scs_ItemGetTtl_Handler,
		},
		{
			MethodName: "ItemGetType",
			Handler:    _Scs_ItemGetType_Handler,
		},
		{
			MethodName: "DictionaryGet",
			Handler:    _Scs_DictionaryGet_Handler,
		},
		{
			MethodName: "DictionaryFetch",
			Handler:    _Scs_DictionaryFetch_Handler,
		},
		{
			MethodName: "DictionarySet",
			Handler:    _Scs_DictionarySet_Handler,
		},
		{
			MethodName: "DictionaryIncrement",
			Handler:    _Scs_DictionaryIncrement_Handler,
		},
		{
			MethodName: "DictionaryDelete",
			Handler:    _Scs_DictionaryDelete_Handler,
		},
		{
			MethodName: "DictionaryLength",
			Handler:    _Scs_DictionaryLength_Handler,
		},
		{
			MethodName: "SetFetch",
			Handler:    _Scs_SetFetch_Handler,
		},
		{
			MethodName: "SetSample",
			Handler:    _Scs_SetSample_Handler,
		},
		{
			MethodName: "SetUnion",
			Handler:    _Scs_SetUnion_Handler,
		},
		{
			MethodName: "SetDifference",
			Handler:    _Scs_SetDifference_Handler,
		},
		{
			MethodName: "SetContains",
			Handler:    _Scs_SetContains_Handler,
		},
		{
			MethodName: "SetLength",
			Handler:    _Scs_SetLength_Handler,
		},
		{
			MethodName: "SetPop",
			Handler:    _Scs_SetPop_Handler,
		},
		{
			MethodName: "ListPushFront",
			Handler:    _Scs_ListPushFront_Handler,
		},
		{
			MethodName: "ListPushBack",
			Handler:    _Scs_ListPushBack_Handler,
		},
		{
			MethodName: "ListPopFront",
			Handler:    _Scs_ListPopFront_Handler,
		},
		{
			MethodName: "ListPopBack",
			Handler:    _Scs_ListPopBack_Handler,
		},
		{
			MethodName: "ListErase",
			Handler:    _Scs_ListErase_Handler,
		},
		{
			MethodName: "ListRemove",
			Handler:    _Scs_ListRemove_Handler,
		},
		{
			MethodName: "ListFetch",
			Handler:    _Scs_ListFetch_Handler,
		},
		{
			MethodName: "ListLength",
			Handler:    _Scs_ListLength_Handler,
		},
		{
			MethodName: "ListConcatenateFront",
			Handler:    _Scs_ListConcatenateFront_Handler,
		},
		{
			MethodName: "ListConcatenateBack",
			Handler:    _Scs_ListConcatenateBack_Handler,
		},
		{
			MethodName: "ListRetain",
			Handler:    _Scs_ListRetain_Handler,
		},
		{
			MethodName: "SortedSetPut",
			Handler:    _Scs_SortedSetPut_Handler,
		},
		{
			MethodName: "SortedSetFetch",
			Handler:    _Scs_SortedSetFetch_Handler,
		},
		{
			MethodName: "SortedSetGetScore",
			Handler:    _Scs_SortedSetGetScore_Handler,
		},
		{
			MethodName: "SortedSetRemove",
			Handler:    _Scs_SortedSetRemove_Handler,
		},
		{
			MethodName: "SortedSetIncrement",
			Handler:    _Scs_SortedSetIncrement_Handler,
		},
		{
			MethodName: "SortedSetGetRank",
			Handler:    _Scs_SortedSetGetRank_Handler,
		},
		{
			MethodName: "SortedSetLength",
			Handler:    _Scs_SortedSetLength_Handler,
		},
		{
			MethodName: "SortedSetLengthByScore",
			Handler:    _Scs_SortedSetLengthByScore_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetBatch",
			Handler:       _Scs_GetBatch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetBatch",
			Handler:       _Scs_SetBatch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cacheclient.proto",
}
